<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0"/>
<title>ElemenTails — Party Select</title>
<style>
:root{ --bg:#0b0c10; --panel:#121520; --muted:#9aa4b2; --accent:#20c997; --danger:#ef4444; }
html,body{height:100%;margin:0;background:var(--bg);color:#e9eef5;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto;}
.shell{max-width:1180px;margin:24px auto;padding:0 16px}
header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px}
.title{font-size:22px;font-weight:900}
.muted{color:var(--muted)}
.btn{appearance:none;border:0;border-radius:10px;padding:10px 12px;font-weight:800;background:#1e2433;color:#fff;cursor:pointer}
.btn.primary{background:var(--accent);color:#042a22}
.btn[disabled]{opacity:.55;cursor:not-allowed}
.row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
.badge{padding:4px 8px;border-radius:999px;background:#0f1220;border:1px solid #273148;font-weight:700;font-size:12px}
.badge.green{background:#0f2a21;border-color:#1c4532;color:#9be4c5}
.card{background:var(--panel);border-radius:12px;padding:12px;border:1px solid #263149}
.board{display:grid;grid-template-columns:repeat(4,1fr);gap:14px}
.col{background:#0f1220;border:1px solid #2a3147;border-radius:12px;overflow:hidden;display:grid;grid-template-rows:auto auto 1fr;gap:10px;padding:10px}
.selectedSlot{height:140px;border-radius:10px;background:#0d111a;border:1px dashed #2a3147;display:flex;align-items:center;justify-content:center;color:#718096;position:relative;overflow:hidden}
.weapon{height:140px;background:#121826;border:1px solid #2a3147;border-radius:10px;display:flex;align-items:center;justify-content:center}
.weapon img{max-width:90%;max-height:90%}
.choices{display:grid;grid-template-rows:repeat(2,120px);gap:10px}
.tile{position:relative;border-radius:10px;overflow:hidden;border:1px solid #2a3147;background:#0e1422;cursor:pointer}
.tile.disabled{opacity:.45;filter:grayscale(.4);cursor:not-allowed}
.tile .bg{width:100%;height:100%;background-size:cover;background-position:center;opacity:.95}
.tag{position:absolute;right:10px;bottom:8px;background:rgba(0,0,0,.6);padding:4px 8px;border-radius:999px;font-size:12px}
.tag.left{left:10px;right:auto}
.picklabel{position:absolute;left:10px;bottom:8px;background:rgba(12,18,28,.7);padding:4px 8px;border-radius:999px;font-size:12px}
@media(max-width:900px){ .board{grid-template-columns:repeat(2,1fr)} }
</style>
</head>
<body>
<div class="shell">
  <header>
    <div class="row">
      <div class="title">Party Select</div>
      <span id="modeBadge" class="badge">Mode</span>
      <span id="lockBadge" class="badge">Unlocked</span>
      <span id="roomBadge" class="badge"></span>
    </div>
    <div class="row">
      <button id="btnToggleMode" class="btn">Switch</button>
      <button id="btnBack" class="btn">Back</button>
      <button id="btnStart" class="btn primary">Start Run</button>
    </div>
  </header>

  <div class="card muted" style="margin-bottom:10px">
    Pick 4 unique heroes — exactly one from each column. Classes are limited to the 4 drawn weapons. Click again to unclaim your pick.
  </div>

  <section id="board" class="board"></section>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js";
import { getFirestore, doc, getDoc, setDoc, updateDoc, runTransaction, onSnapshot, serverTimestamp, arrayUnion } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyBaIjbM7dVNjKE7CJXPQOievhkiIF17rds",
  authDomain: "elementails.firebaseapp.com",
  projectId: "elementails",
  storageBucket: "elementails.firebasestorage.app",
  messagingSenderId: "497100635124",
  appId: "1:497100635124:web:aeeb25ead96b84751e57a1"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);

// -------------------- Data maps --------------------
const WEAPON_TO_CLASSES = {
  knuckles: ['monk','berserker'],
  katana: ['samurai','battlemage'],
  tome: ['cleric','summoner'],
  daggers: ['ninja','assassin'],
  swordshield: ['warrior','paladin'],
  orb: ['druid','wizard'],
  spear: ['lancer','myrmidon'],
  bow: ['archer','bard'],
};
const CLASS_TO_WEAPON = {};
Object.entries(WEAPON_TO_CLASSES).forEach(([w, arr]) => arr.forEach(c => CLASS_TO_WEAPON[c]=w));

// hero identities for "same hero cannot be picked twice"
const CLASS_TO_HERO = {
  monk:'fox', berserker:'frog',
  samurai:'wolf', battlemage:'raccoon',
  cleric:'bunny', summoner:'fox2',
  ninja:'weasel', assassin:'fox',  // assassin shares hero with monk per your rule
  warrior:'bear', paladin:'wolf',  // paladin conflicts with ninja (below) and shares hero with samurai? you requested cross-pair too
  druid:'bunny', wizard:'frog',    // wizard conflicts with berserker
  lancer:'bear', myrmidon:'lizard',
  archer:'otter', bard:'otter2',
};

// Additional Master Rules disallowed pairs (order-agnostic)
const DISALLOWED_PAIRS = new Set([
  'wizard|berserker',
  'berserker|wizard',
  'paladin|ninja',
  'ninja|paladin',
  'assassin|monk',
  'monk|assassin',
]);
function pairKey(a,b){ return `${a}|${b}`; }

// -------------------- Helpers --------------------
const qs = new URLSearchParams(location.search);
const roomId = qs.get('roomId');
const roomRef = doc(db,'rooms', roomId);

const $ = sel => document.querySelector(sel);
function setBadge(el, text, cls){ el.textContent=text; el.className='badge'+(cls?(' '+cls):''); }

function uniqDrawWeapons(rng){
  // draw 4 unique from keys
  const keys = Object.keys(WEAPON_TO_CLASSES);
  for (let i = keys.length -1; i>0; i--) { const j = Math.floor(rng()* (i+1)); [keys[i],keys[j]]=[keys[j],keys[i]]; }
  return keys.slice(0,4);
}
function rngFromSeed(seed='seed'){
  let h=0; for (let i=0;i<seed.length;i++) h = Math.imul(31,h) + seed.charCodeAt(i) | 0;
  return function(){ h = Math.imul(48271, h) % 0x7fffffff; return (h & 0x7fffffff)/0x80000000; };
}

const IMG_CLASS = c=>`images/class-portraits/${c}.png`;
const IMG_WEAPON = w => {
  const n = {knuckles:'knuckles', katana:'katana', tome:'tome', daggers:'daggers', swordshield:'swordshield', orb:'orb', spear:'spear', bow:'bow'}[w] || w;
  return `images/weapons/${n}.png`;
};

// -------------------- UI Build --------------------
function buildBoard(drawnWeapons){
  const board = $('#board'); board.innerHTML='';
  drawnWeapons.forEach((w, colIdx) => {
    const col = document.createElement('div'); col.className='col'; col.dataset.col=colIdx;

    const sel = document.createElement('div'); sel.className='selectedSlot'; sel.innerHTML='— choose a class —'; sel.id=`sel-${colIdx}`;
    const weapon = document.createElement('div'); weapon.className='weapon'; weapon.innerHTML=`<img src="${IMG_WEAPON(w)}" alt="${w}"/>`;

    const choices = document.createElement('div'); choices.className='choices';
    WEAPON_TO_CLASSES[w].forEach(cls => {
      const t = document.createElement('div'); t.className='tile'; t.dataset.class=cls; t.dataset.col=colIdx;
      t.innerHTML = `<div class="bg" style="background-image:url('${IMG_CLASS(cls)}')"></div><div class="tag left">${cls.charAt(0).toUpperCase()+cls.slice(1)}</div>`;
      t.addEventListener('click', () => onPick(colIdx, w, cls));
      choices.appendChild(t);
    });

    col.appendChild(sel); col.appendChild(weapon); col.appendChild(choices);
    board.appendChild(col);
  });
}

function renderPicks(state){
  // update selected top row and disable logic
  const picks = state.picks || [];
  const pickedByCol = new Map();
  picks.forEach(p => pickedByCol.set(p.col, p));

  // Fill selected slots
  for (let c=0;c<4;c++){
    const el = document.getElementById(`sel-${c}`);
    const p = pickedByCol.get(c);
    if (p){
      el.innerHTML = `<div class="tile"><div class="bg" style="background-image:url('${IMG_CLASS(p.class)}')"></div><div class="picklabel">${p.userDisplay || 'Player'}</div></div>`;
    }else{
      el.innerHTML = '— choose a class —';
    }
  }

  // Compute disabled set based on rules
  const takenClasses = new Set(picks.map(p=>p.class));
  const takenWeapons = new Set(picks.map(p=>p.weapon));
  const takenHeroes = new Set(picks.map(p=>CLASS_TO_HERO[p.class]));

  const disallowedByMaster = new Set();
  picks.forEach(p => {
    Object.keys(CLASS_TO_WEAPON).forEach(cls => {
      if (DISALLOWED_PAIRS.has(pairKey(p.class, cls))) disallowedByMaster.add(cls);
    });
  });

  document.querySelectorAll('.tile').forEach(tile => {
    const cls = tile.dataset.class;
    const col = parseInt(tile.dataset.col);
    const ownerPick = pickedByCol.get(col);
    let disabled = false;

    // If this column already has a pick and it's not this class, disable
    if (ownerPick && ownerPick.class !== cls) disabled = true;

    // If any taken conflicts with this cls: same class (takenClasses), same weapon, same hero, or master disallowed
    if (!ownerPick){ // allow clicking again on your own pick handled by onPick
      if (takenClasses.has(cls)) disabled = true;
      const w = CLASS_TO_WEAPON[cls];
      if (takenWeapons.has(w)) disabled = true;
      const hero = CLASS_TO_HERO[cls];
      if (takenHeroes.has(hero)) disabled = true;
      if (disallowedByMaster.has(cls)) disabled = true;
    }

    tile.classList.toggle('disabled', disabled);
  });
}

// -------------------- Firestore sync --------------------
let me=null, room=null;
onAuthStateChanged(auth, async (user) => {
  if (!user) { await signInWithPopup(auth, new GoogleAuthProvider()); return; }
  me=user;
  const snap = await getDoc(roomRef);
  if (!snap.exists()){ alert('Room not found'); return; }
  room = snap.data();

  // ensure participant
  if (!Array.isArray(room.participantUids) || !room.participantUids.includes(me.uid)){
    try{ await updateDoc(roomRef, { participantUids: arrayUnion(me.uid) }); }catch{}
  }

  // draw weapons once if missing
  if (!Array.isArray(room.drawnWeapons) || room.drawnWeapons.length!==4){
    const seed = room.seed || roomRef.id;
    const draw = uniqDrawWeapons(rngFromSeed(seed));
    await updateDoc(roomRef, { drawnWeapons: draw, updatedAt: serverTimestamp() });
  }

  onSnapshot(roomRef, (s) => {
    if (!s.exists()) return;
    room = s.data();
    $('#roomBadge').textContent = 'Room ' + roomRef.id.slice(0,6)+'…';
    const isMulti = (room.visibility === 'friends' || room.visibility === 'public');
    setBadge($('#modeBadge'), isMulti ? 'Multiplayer' : 'Singleplayer', 'green');
    setBadge($('#lockBadge'), room.rosterLocked ? 'Locked' : 'Unlocked');

    // build if not built
    if (Array.from(document.querySelectorAll('.col')).length === 0 && Array.isArray(room.drawnWeapons)){
      buildBoard(room.drawnWeapons);
    }
    renderPicks({
      picks: (room.picks||[]).map(p=>({...p, userDisplay: p.userDisplay || p.uid?.slice(0,6)}))
    });

    $('#btnToggleMode').disabled = !!room.rosterLocked;
    $('#btnStart').disabled = !!room.rosterLocked || (room.picks||[]).length<4;
  });
});

async function onPick(col, weapon, cls){
  if (room?.rosterLocked) return;
  await runTransaction(db, async (tx)=>{
    const rs = await tx.get(roomRef);
    if (!rs.exists()) throw new Error('Room missing');
    const data = rs.data();
    const picks = data.picks || [];
    // if this user already picked in this column, toggle (unclaim) if same, or switch
    const existingIdx = picks.findIndex(p=>p.col===col);
    if (existingIdx>=0){
      const p = picks[existingIdx];
      if (p.uid===me.uid){
        if (p.class===cls){
          // unclaim
          picks.splice(existingIdx,1);
        }else{
          // switch within the column
          picks[existingIdx] = { col, weapon, class: cls, uid: me.uid, userDisplay: me.displayName || 'Player', t: Date.now() };
        }
      }else{
        // another user owns the column
        return;
      }
    }else{
      // enforce legality before adding
      // check existing picks for conflicts with this cls
      const illegal = picks.some(p => {
        if (p.class === cls) return True;
        if (CLASS_TO_WEAPON[p.class] === CLASS_TO_WEAPON[cls]) return True;
        if (CLASS_TO_HERO[p.class] === CLASS_TO_HERO[cls]) return True;
        if (DISALLOWED_PAIRS.has(pairKey(p.class, cls))) return True;
        return False;
      });
      if (illegal) return;
      picks.push({ col, weapon, class: cls, uid: me.uid, userDisplay: me.displayName || 'Player', t: Date.now() });
    }
    tx.update(roomRef, { picks, updatedAt: serverTimestamp() });
  });
}

document.getElementById('btnBack').addEventListener('click', ()=> history.back());
document.getElementById('btnToggleMode').addEventListener('click', async ()=>{
  if (room?.rosterLocked) return;
  const isMulti = (room.visibility === 'friends' || room.visibility === 'public');
  await updateDoc(roomRef, { visibility: isMulti?'private':'friends', updatedAt: serverTimestamp() });
});
document.getElementById('btnStart').addEventListener('click', async ()=>{
  if (!room) return;
  const picks = room.picks || [];
  if (picks.length !== 4){ alert('Pick one per column first.'); return; }
  const uids = Array.from(new Set((room.participantUids||[]).concat(picks.map(p=>p.uid))));
  const classByUid = {}; picks.forEach(p=> classByUid[p.uid]=p.class);
  await updateDoc(roomRef, {
    rosterLocked: true,
    lockedPartyUids: uids,
    classByUid,
    status: 'in_progress',
    startedAt: serverTimestamp(),
    updatedAt: serverTimestamp()
  });
});

</script>
</body>
</html>
