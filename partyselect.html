<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1.0"/>
  <title>ElemenTails — Party Select</title>
  <style>
    :root{--bg:#0b0c10;--panel:#121520;--muted:#9aa4b2;--accent:#20c997;--radius:12px}
    html,body{height:100%;margin:0;background:var(--bg);color:#e9eef5;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto}
    .shell{max-width:1200px;margin:22px auto;padding:0 16px}
    header{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .title{font-size:22px;font-weight:900}
    .badge{padding:4px 8px;border-radius:999px;background:#0f1220;border:1px solid #273148;font-weight:700;font-size:12px}
    .badge.green{background:#0f2a21;border-color:#1c4532;color:#9be4c5}
    .btn{appearance:none;border:0;border-radius:10px;padding:10px 12px;font-weight:800;background:#1e2433;color:#fff;cursor:pointer}
    .btn.primary{background:var(--accent);color:#032922}
    .btn[disabled]{opacity:.55;cursor:not-allowed}
    .card{background:var(--panel);border:1px solid #263149;border-radius:12px;padding:12px}
    .muted{color:#9aa4b2}
    .grid{display:grid;grid-template-columns:repeat(4,1fr);gap:12px}
    .slot,.weapon,.opt{position:relative;border-radius:12px;background:#0f1220;border:1px solid #263149;overflow:hidden}
    .slot{height:160px;display:flex;align-items:center;justify-content:center;color:#9aa4b2}
    .weapon{height:160px;display:flex;align-items:center;justify-content:center;background:#0b1020}
    .opt{height:160px;cursor:pointer}
    .opt.disabled{opacity:.45;filter:grayscale(0.9);cursor:not-allowed}
    .img{width:100%;height:100%;background-size:cover;background-position:center}
    .tag{position:absolute;right:8px;bottom:8px;background:rgba(0,0,0,.6);padding:4px 8px;border-radius:999px;font-weight:800;font-size:12px}
  </style>
</head>
<body>
  <div class="shell">
    <header>
      <div class="row">
        <div class="title">Party Select</div>
        <span id="modeBadge" class="badge">Singleplayer</span>
        <span id="lockBadge" class="badge">Unlocked</span>
        <span id="roomBadge" class="badge"></span>
      </div>
      <div class="row">
        <button id="btnToggleMode" class="btn">Switch to Multiplayer</button>
        <button id="btnBack" class="btn">Back</button>
        <button id="btnStart" class="btn primary">Start Run</button>
      </div>
    </header>

    <div class="card muted" style="margin-bottom:10px">
      Pick 4 unique heroes — exactly one from each column. Classes are limited to the 4 drawn weapons. Click again to unclaim your pick.
    </div>

    <section id="board" class="card">
      <div id="grid" class="grid">
        <!-- Column 1 -->
        <div id="slot0" class="slot"><span>— choose a class —</span></div>
        <div id="slot1" class="slot"><span>— choose a class —</span></div>
        <div id="slot2" class="slot"><span>— choose a class —</span></div>
        <div id="slot3" class="slot"><span>— choose a class —</span></div>

        <div id="weapon0" class="weapon"></div>
        <div id="weapon1" class="weapon"></div>
        <div id="weapon2" class="weapon"></div>
        <div id="weapon3" class="weapon"></div>

        <div id="opt0a" class="opt"></div>
        <div id="opt1a" class="opt"></div>
        <div id="opt2a" class="opt"></div>
        <div id="opt3a" class="opt"></div>

        <div id="opt0b" class="opt"></div>
        <div id="opt1b" class="opt"></div>
        <div id="opt2b" class="opt"></div>
        <div id="opt3b" class="opt"></div>
      </div>
      <div class="muted" style="text-align:center;margin-top:8px">Click a class tile to claim it. You can click again to unclaim your own choice.</div>
    </section>
  </div>

  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
    import { getAuth, GoogleAuthProvider, signInWithPopup, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-auth.js";
    import {
      getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, serverTimestamp, arrayUnion, runTransaction
    } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBaIjbM7dVNjKE7CJXPQOievhkiIF17rds",
      authDomain: "elementails.firebaseapp.com",
      projectId: "elementails",
      storageBucket: "elementails.firebasestorage.app",
      messagingSenderId: "497100635124",
      appId: "1:497100635124:web:aeeb25ead96b84751e57a1"
    };

    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    // --- assets
    const IMG = (name) => `images/class-portraits/${name}.png`;
    const ICON = (name) => `images/weapons/${name}.png`; // adjust if different

    // classes -> hero + weapon
    const CLASSES = {
      monk:       { title:"Monk",       hero:"fox",    weapon:"knuckles", img:"monk" },
      berserker:  { title:"Berserker",  hero:"frog",   weapon:"knuckles", img:"berserker" },
      battlemage: { title:"Battlemage", hero:"raven",  weapon:"katana",   img:"battlemage" },
      samurai:    { title:"Samurai",    hero:"wolf",   weapon:"katana",   img:"samurai" },
      cleric:     { title:"Cleric",     hero:"rabbit", weapon:"tome",     img:"cleric" },
      summoner:   { title:"Summoner",   hero:"fox",    weapon:"tome",     img:"summoner" },
      paladin:    { title:"Paladin",    hero:"wolf",   weapon:"swordshield", img:"paladin" },
      warrior:    { title:"Warrior",    hero:"bear",   weapon:"warrior",  img:"warrior", weaponOverride:"swordshield" },
      ninja:      { title:"Ninja",      hero:"frog",   weapon:"daggers",  img:"ninja" },
      assassin:   { title:"Assassin",   hero:"raccoon",weapon:"daggers",  img:"assassin" },
      druid:      { title:"Druid",      hero:"rabbit", weapon:"staff",    img:"druid" },
      wizard:     { title:"Wizard",     hero:"lizard", weapon:"staff",    img:"wizard" },
    };
    // weapon -> classes (two vertically)
    const W2C = {
      knuckles: ["monk","berserker"],
      katana:   ["battlemage","samurai"],
      tome:     ["cleric","summoner"],
      daggers:  ["ninja","assassin"],
      swordshield: ["paladin","warrior"],
      staff: ["druid","wizard"],
    };
    const WEAPON_ICON = {
      knuckles:"knuckles",
      katana:"katana",
      tome:"tome",
      daggers:"daggers",
      swordshield:"sword_shield",
      staff:"orb_staff"
    };

    // --- helpers
    const $ = sel => document.querySelector(sel);
    const qs = new URLSearchParams(location.search);
    const roomId = qs.get('roomId');
    const roomRef = doc(db,'rooms', roomId);

    function uniqRand(arr, n){
      const pool = arr.slice();
      const out = [];
      while (out.length < n && pool.length){
        const i = Math.floor(Math.random()*pool.length);
        out.push(pool.splice(i,1)[0]);
      }
      return out;
    }

    const state = {
      me:null,
      room:null,
      columns:[], // [{weapon, aClass, bClass}]
      picks:[],   // [{col, classKey, uid}]
    };

    function setBadge(el, text, cls){ el.textContent=text; el.className='badge'+(cls?' '+cls:''); }

    // --- auth/bootstrap
    onAuthStateChanged(auth, async (user)=>{
      if (!user){ await signInWithPopup(auth, new GoogleAuthProvider()); return; }
      state.me = user;
      initRoom();
    });

    function classesConflict(classKey, pickedSet){
      const c = CLASSES[classKey];
      // conflict if any picked class shares the same hero or same weapon
      for (const k of pickedSet){
        const pc = CLASSES[k];
        const w = (CLASSES[classKey].weaponOverride || c.weapon);
        const pw = (pc.weaponOverride || pc.weapon);
        if (pc.hero === c.hero) return true;
        if (pw === w) return true;
      }
      return false;
    }

    function renderBoard(){
      // top slot labels
      for (let i=0;i<4;i++){
        const s = $(`#slot${i}`);
        s.innerHTML = '<span>— choose a class —</span>';
      }
      // weapons
      for (let i=0;i<4;i++){
        const col = state.columns[i];
        const wKey = col.weapon;
        const iconName = WEAPON_ICON[wKey] || wKey;
        $(`#weapon${i}`).innerHTML = `<div class="img" style="background-image:url('images/weapons/${iconName}.png')"></div>`;
      }
      // options vertically under each weapon
      for (let i=0;i<4;i++){
        const col = state.columns[i];
        const [a,b] = W2C[col.weapon];
        const aEl = $(`#opt${i}a`);
        const bEl = $(`#opt${i}b`);
        aEl.innerHTML = `<div class="img" style="background-image:url('${IMG(CLASSES[a].img)}')"></div><div class="tag">${CLASSES[a].title}</div>`;
        bEl.innerHTML = `<div class="img" style="background-image:url('${IMG(CLASSES[b].img)}')"></div><div class="tag">${CLASSES[b].title}</div>`;
        aEl.onclick = ()=> tryPick(i,a);
        bEl.onclick = ()=> tryPick(i,b);
        aEl.classList.remove('disabled');
        bEl.classList.remove('disabled');
      }
      // apply existing picks
      applyPicksToUI();
    }

    function applyPicksToUI(){
      const pickedByCol = new Map();
      const pickedClassSet = new Set();
      for (const p of state.picks){
        pickedByCol.set(p.col, p);
        pickedClassSet.add(p.classKey);
      }
      // set slot images
      for (let i=0;i<4;i++){
        const slotEl = $(`#slot${i}`);
        if (pickedByCol.has(i)){
          const p = pickedByCol.get(i);
          const c = CLASSES[p.classKey];
          slotEl.innerHTML = `<div class="img" style="background-image:url('${IMG(c.img)}')"></div><div class="tag">${p.name||'Picked'}</div>`;
        } else {
          slotEl.innerHTML = `<span>— choose a class —</span>`;
        }
      }
      // disable options:
      for (let i=0;i<4;i++){
        const col = state.columns[i];
        const [a,b] = W2C[col.weapon];
        const aEl = $(`#opt${i}a`);
        const bEl = $(`#opt${i}b`);
        // if column already picked by someone: disable both except allow owner to unpick by clicking slot? We'll allow clicking same tile again to unclaim
        const p = state.picks.find(x=>x.col===i);
        aEl.classList.remove('disabled'); bEl.classList.remove('disabled');
        if (p){
          // disable opposite tile and also disable same tile for others
          if (p.classKey===a){ bEl.classList.add('disabled'); }
          if (p.classKey===b){ aEl.classList.add('disabled'); }
        }
        // global conflicts (hero/weapon) — only disable if not already the chosen one
        const conflictA = classesConflict(a, pickedClassSet) && !state.picks.find(x=>x.classKey===a);
        const conflictB = classesConflict(b, pickedClassSet) && !state.picks.find(x=>x.classKey===b);
        if (conflictA) aEl.classList.add('disabled');
        if (conflictB) bEl.classList.add('disabled');
      }
    }

    async function tryPick(col, classKey){
      const me = state.me;
      if (!me) return;
      // unclaim if already mine on this col
      const myPick = state.picks.find(p=>p.col===col && p.uid===me.uid);
      if (myPick && myPick.classKey===classKey){
        await runTransaction(db, async tx=>{
          const r = await tx.get(roomRef);
          if (!r.exists()) throw new Error('room');
          const picks = (r.data().picks||[]).filter(x=>!(x.col===col && x.uid===me.uid));
          tx.update(roomRef,{ picks, updatedAt: serverTimestamp() });
        });
        return;
      }
      // else claim
      await runTransaction(db, async tx=>{
        const r = await tx.get(roomRef);
        if (!r.exists()) throw new Error('room');
        const d = r.data();
        const picks = d.picks || [];
        // column already claimed by someone else?
        if (picks.some(x=>x.col===col && x.uid!==me.uid)) return;
        // enforce hero uniqueness and weapon uniqueness globally
        const pickedClasses = new Set(picks.map(x=>x.classKey));
        if (classesConflict(classKey, pickedClasses)) return;

        // clear my previous pick in this column if any
        const filtered = picks.filter(x=>!(x.col===col && x.uid===me.uid));
        filtered.push({ col, classKey, uid: me.uid, name: (d.displayNames?.[me.uid]||'You'), t: Date.now() });
        tx.update(roomRef,{ picks: filtered, updatedAt: serverTimestamp() });
      });
    }

    async function initRoom(){
      if (!roomId){ alert('Missing room id'); return; }
      onSnapshot(roomRef, (snap)=>{
        if (!snap.exists()){ alert('Room not found'); return; }
        const d = snap.data();
        state.room = d;
        // badges
        const isMulti = (d.visibility==='friends' || d.visibility==='public');
        setBadge($('#modeBadge'), isMulti?'Multiplayer':'Singleplayer', 'green');
        setBadge($('#lockBadge'), d.rosterLocked?'Locked':'Unlocked');
        $('#btnToggleMode').disabled = !!d.rosterLocked;
        $('#btnStart').disabled = !!d.rosterLocked;
        $('#roomBadge').textContent = 'Room ' + roomId.slice(0,6)+'…';

        // ensure drawnWeapons (unique)
        let dw = d.drawnWeapons;
        const allW = Object.keys(W2C);
        if (!Array.isArray(dw) || dw.length!==4){
          const chosen = uniqRand(allW,4);
          updateDoc(roomRef,{ drawnWeapons: chosen, updatedAt: serverTimestamp() });
          return; // will re-render on next snapshot
        }
        // build columns based on weapons with vertical pairs
        state.columns = dw.map(w=>({ weapon:w }));
        // picks
        state.picks = (d.picks||[]);
        renderBoard();
      });

      $('#btnToggleMode').addEventListener('click', async ()=>{
        const d = state.room; if (!d || d.rosterLocked) return;
        const isMulti = (d.visibility==='friends' || d.visibility==='public');
        const next = isMulti ? 'private' : 'friends';
        await updateDoc(roomRef,{ visibility: next, updatedAt: serverTimestamp() });
      });
      $('#btnBack').addEventListener('click', ()=> history.back());
      $('#btnStart').addEventListener('click', async ()=>{
        const d = state.room; if (!d) return;
        const participants = Array.isArray(d.participantUids)?d.participantUids:[auth.currentUser.uid];
        const classByUid = {};
        for (const p of (d.picks||[])){ classByUid[p.uid]=p.classKey; }
        await updateDoc(roomRef,{
          rosterLocked:true,
          lockedPartyUids:participants,
          classByUid,
          status:'in_progress',
          startedAt: serverTimestamp(),
          updatedAt: serverTimestamp()
        });
      });
    }
  </script>
</body>
</html>
