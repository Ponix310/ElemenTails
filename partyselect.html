<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ElemenTails — Party Select</title>
  <style>
    :root{
      --panel: #141922;
      --panel-2: #0f141c;
      --text: #e9eef6;
      --muted: #a9b2c2;
      --shadow: 0 10px 30px rgba(0,0,0,.45);
      --radius: 16px;
      --gap: 18px;
      --box-border: 2px solid rgba(255,255,255,.06);
      --accent: #fbbf24;
      --ok: #22c55e;
      --warn: #f59e0b;
      --danger: #ef4444;
      --pick: #34d399;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; background: radial-gradient(1200px 1200px at 10% 10%, #111927 0%, #0b0f15 60%, #070a0f 100%);
      color: var(--text); margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif; }
    header { display:flex; align-items:center; justify-content:space-between; padding: 20px clamp(16px, 4vw, 40px);
      border-bottom: 1px solid rgba(255,255,255,.08); backdrop-filter: blur(6px); position: sticky; top: 0; z-index: 10;
      background: linear-gradient(180deg, rgba(20,25,34,.9), rgba(20,25,34,.65)); }
    header .title{ display:flex; gap:14px; align-items:baseline; }
    header .title h1{ margin:0; font-size: clamp(18px, 2.2vw, 26px); letter-spacing:.4px; }
    header .title .sub{ color:var(--muted); font-size: clamp(12px, 1.4vw, 14px); }
    header .actions{ display:flex; gap:10px; }
    .btn{ appearance:none; background:#1b2431; border:1px solid rgba(255,255,255,.08); color:var(--text); padding:10px 14px;
      border-radius:10px; cursor:pointer; font-weight:600; box-shadow:var(--shadow); text-decoration:none; transition:transform .06s ease; }
    .btn:active{ transform: translateY(1px); }
    .btn.primary{ background: linear-gradient(180deg, #1e293b, #1b2431); border-color: rgba(250,204,21,.25); }
    .btn[disabled]{ opacity:.5; cursor:not-allowed; }
    .page{ padding:16px clamp(16px, 4vw, 40px) 40px; max-width:1500px; margin:0 auto; }

    .modeNotice{ margin: 8px 0 18px; padding: 10px 14px; border-radius: 12px;
      background: rgba(255,255,255,.03); border: 1px solid rgba(255,255,255,.08); display:flex; align-items:center; gap:10px;
      font-size:14px; color:var(--muted); }
    .pill{ padding:2px 8px; border-radius:999px; font-weight:700; font-size:12px; border:1px solid rgba(255,255,255,.12); }
    .pill.ok{ background: rgba(34,197,94,.15); color:#bbf7d0; border-color:rgba(34,197,94,.25); }
    .pill.warn{ background: rgba(245,158,11,.18); color:#fde68a; border-color:rgba(245,158,11,.25); }

    .grid { display:grid; grid-template-columns: repeat(4,1fr); grid-auto-rows:auto; gap: var(--gap); }
    .frame{ position:relative; overflow:hidden; border-radius:var(--radius); background: linear-gradient(160deg, var(--panel), var(--panel-2));
      border: var(--box-border); box-shadow: var(--shadow); min-height: 160px; display:flex; align-items:center; justify-content:center; isolation:isolate; }
    .frame.large{ min-height: clamp(160px, 18vw, 240px); }
    .frame.icon{ min-height: clamp(90px, 10vw, 130px); padding:8px; }
    .frame.option{ min-height: clamp(140px, 16vw, 220px); }
    .frame img{ width:100%; height:100%; object-fit:cover; display:block; }
    .frame.icon img{ width:auto; height:80%; object-fit:contain; padding:6px; filter: drop-shadow(0 4px 18px rgba(0,0,0,.35)); }
    .label-top{ position:absolute; top:8px; left:10px; background: rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.12);
      color:var(--text); padding:4px 8px; border-radius:8px; font-size:12px; z-index:3; }
    .label-bottom{ position:absolute; bottom:8px; right:10px; background: rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.12);
      color:var(--text); padding:4px 8px; border-radius:8px; font-size:12px; z-index:3; }

    .disabled{ opacity:.45; filter:grayscale(.8); pointer-events:none; }
    .selected{ outline: 3px solid var(--pick); box-shadow: 0 0 0 3px rgba(52,211,153,.15) inset, var(--shadow); }
    .picked-badge{ position:absolute; bottom:8px; left:10px; background: rgba(52,211,153,.18); color:#d1fae5;
      border:1px solid rgba(52,211,153,.35); padding:4px 8px; border-radius:8px; font-size:12px; z-index:3; }

    .hint{ text-align:center; color:var(--muted); font-size:13px; margin-top:6px; grid-column:1/-1; }

    @media (max-width:980px){ .grid{ grid-template-columns: repeat(2,1fr);} }
    @media (max-width:560px){ header .actions{ display:none;} .grid{ grid-template-columns:1fr;} }
  </style>
  <!-- Firebase (for pulling player usernames when roomId is present) -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-app.js";
    import { getFirestore, doc, getDoc } from "https://www.gstatic.com/firebasejs/12.1.0/firebase-firestore.js";

    const firebaseConfig = {
      apiKey: "AIzaSyBaIjbM7dVNjKE7CJXPQOievhkiIF17rds",
      authDomain: "elementails.firebaseapp.com",
      projectId: "elementails",
      storageBucket: "elementails.firebasestorage.app",
      messagingSenderId: "497100635124",
      appId: "1:497100635124:web:aeeb25ead96b84751e57a1"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // Expose minimal Firestore helpers to the page scope
    window._et_fetchRoom = async (roomId) => {
      try { const s = await getDoc(doc(db,'rooms', roomId)); return s.exists() ? s.data() : null; } catch { return null; }
    };
    window._et_fetchUsername = async (uid) => {
      try {
        const u = await getDoc(doc(db,'users', uid));
        if (u.exists() && u.data().username) return u.data().username;
      } catch {}
      try {
        const p = await getDoc(doc(db,'publicProfiles', uid));
        if (p.exists() && (p.data().username || p.data().displayName)) return p.data().username || p.data().displayName;
      } catch {}
      return uid.slice(0,6);
    };
  </script>
</head>
<body>
  <header>
    <div class="title">
      <h1>Party Select</h1>
      <span class="sub">Pick 4 unique heroes. Classes limited to the 4 drawn weapons.</span>
    </div>
    <div class="actions">
      <a class="btn" href="mainmenu.html">Back</a>
      <a id="startBtn" class="btn primary" href="game.html" disabled>Start Run</a>
    </div>
  </header>

  <main class="page">
    <div id="modeNotice" class="modeNotice">
      <span id="modePill" class="pill">Mode</span>
      <span id="modeText">Loading…</span>
    </div>

    <!-- Row 1: ordered picks (portraits) with player names as labels -->
    <section class="grid" id="row-picked" aria-label="picked-classes"></section>

    <!-- Row 2: the four drawn weapons (static) -->
    <section class="grid" id="row-weapons" aria-label="drawn-weapons"></section>

    <!-- Rows 3 & 4: two choices per column, based on the weapon above -->
    <section class="grid" id="row-choices-a" aria-label="choices-top"></section>
    <section class="grid" id="row-choices-b" aria-label="choices-bottom"></section>

    <div class="hint" id="hint">Click one of the bottom tiles to choose a class. Click again to unclaim it.</div>
  </main>

  <script>
  // ---------- Helpers
  const $ = (sel, el=document) => el.querySelector(sel);
  const el = (tag, cls) => { const n = document.createElement(tag); if(cls) n.className = cls; return n; };
  const img = (src, alt='') => { const i = new Image(); i.src = src; i.alt = alt; return i; };
  const shuffle = (arr) => arr.map(v => [Math.random(), v]).sort((a,b)=>a[0]-b[0]).map(([,v])=>v);

  // ---------- URL / Storage keys
  const URL_QS = new URLSearchParams(location.search);
  const ROOM_ID = URL_QS.get('roomId') || null;
  const LS_KEY  = `ET_ps_v3:${ROOM_ID || 'standalone'}`;

  // ---------- Mode & player labels
  function resolveMode(){
    const qp = (URL_QS.get('mode') || '').toLowerCase();
    if (['single','sp'].includes(qp)) return 'single';
    if (['multi','mp','multiplayer'].includes(qp)) return 'multi';
    const et = (localStorage.getItem('ET_mode') || '').toLowerCase();
    if (['multi','multiplayer','friends','public'].includes(et)) return 'multi';
    if (['single','sp','solo','private'].includes(et)) return 'single';
    return 'single';
  }
  function resolveNames(){
    try{
      const arr = JSON.parse(localStorage.getItem('ET_players') || '[]');
      if (Array.isArray(arr) && arr.length) return arr.slice(0,4).concat(['Slot 3','Slot 4']).slice(0,4);
    }catch(_){}
    return ['Slot 1','Slot 2','Slot 3','Slot 4'];
  }

  // ---------- Assets
  const WEAPONS = [
    { id: 'bow',          name: 'Bow',           icon: 'images/weapons/bow.png' },
    { id: 'daggers',      name: 'Daggers',       icon: 'images/weapons/daggers.png' },
    { id: 'greataxe',     name: 'Greataxe',      icon: 'images/weapons/greataxe.png' },
    { id: 'katana',       name: 'Katana',        icon: 'images/weapons/katana.png' },
    { id: 'knuckles',     name: 'Knuckles',      icon: 'images/weapons/knuckles.png' },
    { id: 'spear',        name: 'Spear',         icon: 'images/weapons/spear.png' },
    { id: 'staff',        name: 'Staff',         icon: 'images/weapons/staff.png' },
    { id: 'sword-shield', name: 'Sword & Shield',icon: 'images/weapons/sword-shield.png' },
    { id: 'tome',         name: 'Tome',          icon: 'images/weapons/tome.png' },
  ];
  const CLASSES = [
    { id:'archer',     name:'Archer',     hero:'raven',  weapon:'bow',          portrait:'images/class-portraits/archer.png' },
    { id:'assassin',   name:'Assassin',   hero:'fox',    weapon:'daggers',      portrait:'images/class-portraits/assassin.png' },
    { id:'barbearian', name:'Barbearian', hero:'bear',   weapon:'greataxe',     portrait:'images/class-portraits/barbearian.png' },
    { id:'bard',       name:'Bard',       hero:'rabbit', weapon:'bow',          portrait:'images/class-portraits/bard.png' },
    { id:'battlemage', name:'Battlemage', hero:'raven',  weapon:'katana',       portrait:'images/class-portraits/battlemage.png' },
    { id:'berserker',  name:'Berserker',  hero:'frog',   weapon:'knuckles',     portrait:'images/class-portraits/berserker.png' },
    { id:'cleric',     name:'Cleric',     hero:'rabbit', weapon:'tome',         portrait:'images/class-portraits/cleric.png' },
    { id:'druid',      name:'Druid',      hero:'rabbit', weapon:'staff',        portrait:'images/class-portraits/druid.png' },
    { id:'lancer',     name:'Lancer',     hero:'bear',   weapon:'spear',        portrait:'images/class-portraits/lancer.png' },
    { id:'monk',       name:'Monk',       hero:'fox',    weapon:'knuckles',     portrait:'images/class-portraits/monk.png' },
    { id:'myrmidon',   name:'Myrmidon',   hero:'frog',   weapon:'spear',        portrait:'images/class-portraits/myrmidon.png' },
    { id:'ninja',      name:'Ninja',      hero:'wolf',   weapon:'daggers',      portrait:'images/class-portraits/ninja.png' },
    { id:'paladin',    name:'Paladin',    hero:'wolf',   weapon:'sword-shield', portrait:'images/class-portraits/paladin.png' },
    { id:'reaper',     name:'Reaper',     hero:'raven',  weapon:'greataxe',     portrait:'images/class-portraits/reaper.png' },
    { id:'samurai',    name:'Samurai',    hero:'wolf',   weapon:'katana',       portrait:'images/class-portraits/samurai.png' },
    { id:'summoner',   name:'Summoner',   hero:'fox',    weapon:'tome',         portrait:'images/class-portraits/summoner.png' },
    { id:'warrior',    name:'Warrior',    hero:'bear',   weapon:'sword-shield', portrait:'images/class-portraits/warrior.png' },
    { id:'wizard',     name:'Wizard',     hero:'frog',   weapon:'staff',        portrait:'images/class-portraits/wizard.png' },
  ];

  // Lookups
  const byWeapon = (w) => CLASSES.filter(c => c.weapon === w);
  const weapon = (id) => WEAPONS.find(w => w.id === id);
  const clazz  = (id) => CLASSES.find(c => c.id === id);

  // ---------- State
  const state = {
    mode: 'single',
    names: resolveNames(),     // turn order display names (updated from room if available)
    drawn: [],                 // 4 weapon ids
    picks: [],                 // ordered picks: [{classId, weaponId, playerName}]
  };

  function persist(){ localStorage.setItem(LS_KEY, JSON.stringify({ names: state.names, drawn: state.drawn, picks: state.picks })); }
  function restore(){
    try{
      const raw = localStorage.getItem(LS_KEY); if(!raw) return false;
      const d = JSON.parse(raw) || {};
      if (Array.isArray(d.names) && d.names.length) state.names = d.names;
      if (Array.isArray(d.drawn) && d.drawn.length === 4) state.drawn = d.drawn;
      if (Array.isArray(d.picks)) state.picks = d.picks.filter(p => p && p.classId && p.weaponId && p.playerName);
      return true;
    }catch(_){ return false; }
  }

  const pickedIndex = (classId) => state.picks.findIndex(p => p.classId === classId);
  const heroTaken = (hero) => state.picks.some(p => clazz(p.classId)?.hero === hero);
  const alreadyPicked = (classId) => pickedIndex(classId) !== -1;

  function canPick(classId, columnIndex){
    if (state.picks.length >= 4) return false;
    const c = clazz(classId); if (!c) return false;
    if (alreadyPicked(classId)) return false;
    if (heroTaken(c.hero)) return false;
    return c.weapon === state.drawn[columnIndex];
  }
  function unpick(classId){
    const idx = pickedIndex(classId);
    if (idx === -1) return;
    state.picks.splice(idx, 1);
    persist(); render();
  }
  function doPick(classId, columnIndex){
    if (!canPick(classId, columnIndex)) return;
    const turn = state.picks.length % Math.max(1, state.names.length);
    const playerName = state.names[turn] || `Slot ${turn+1}`;
    state.picks.push({ classId, weaponId: state.drawn[columnIndex], playerName });
    persist(); render();
  }
  function drawWeapons(){ state.drawn = shuffle([...WEAPONS]).slice(0,4).map(w=>w.id); }

  // ---------- Rendering
  function renderBanner(){
    const pill = $('#modePill'); const text = $('#modeText');
    if (state.mode === 'multi'){ pill.textContent='Multiplayer'; pill.className='pill ok'; text.textContent='Friends may join until 4 picks are made.'; }
    else { pill.textContent='Single Player'; pill.className='pill warn'; text.textContent='Lobby locked. You will fill all 4 slots.'; }
  }
  function renderButtons(){ $('#startBtn').disabled = state.picks.length !== 4; }
  function clearRow(id){ const r=$(id); if(r) r.innerHTML=''; }

  function render(){
    renderBanner(); renderButtons();
    clearRow('#row-picked'); clearRow('#row-weapons'); clearRow('#row-choices-a'); clearRow('#row-choices-b');

    // Row 1: ordered picks
    for (let i=0;i<4;i++){
      const box = el('div','frame large');
      const p = state.picks[i];
      if (p){
        const c = clazz(p.classId);
        box.appendChild(img(c.portrait, c.name));
        const tag1 = el('div','label-top'); tag1.textContent = c.name; box.appendChild(tag1);
        const tag2 = el('div','label-bottom'); tag2.textContent = p.playerName; box.appendChild(tag2);
      } else {
        const ph = el('div'); ph.style.opacity=.55; ph.style.fontSize='14px'; ph.textContent='— choose a class —';
        box.appendChild(ph);
      }
      $('#row-picked').appendChild(box);
    }

    // Row 2: drawn weapons
    state.drawn.forEach((wId) => {
      const w = weapon(wId);
      const b = el('div','frame icon'); b.appendChild(img(w.icon, w.name));
      $('#row-weapons').appendChild(b);
    });

    // Rows 3 & 4: two choices per column
    state.drawn.forEach((wId, col) => {
      const pair = byWeapon(wId);

      const buildChoice = (c, targetRowId) => {
        const tile = el('div','frame option');
        tile.appendChild(img(c.portrait, c.name));
        const tLab = el('div','label-top'); tLab.textContent = c.name; tile.appendChild(tLab);

        const isPicked = alreadyPicked(c.id);
        const legal = canPick(c.id, col);

        if (isPicked){
          const who = state.picks[pickedIndex(c.id)]?.playerName || 'Picked';
          const badge = el('div','picked-badge'); badge.textContent = `Picked by ${who}`;
          tile.appendChild(badge);
          tile.classList.add('selected');
          tile.addEventListener('click', () => unpick(c.id));
        } else if (legal){
          tile.style.cursor = 'pointer';
          tile.addEventListener('click', () => doPick(c.id, col));
        } else {
          tile.classList.add('disabled');
        }
        $(targetRowId).appendChild(tile);
      };

      buildChoice(pair[0], '#row-choices-a');
      buildChoice(pair[1], '#row-choices-b');
    });
  }

  // ---------- Room-based player names (if roomId is present)
  async function tryPopulateNamesFromRoom(){
    if (!ROOM_ID || typeof window._et_fetchRoom !== 'function') return;
    const room = await window._et_fetchRoom(ROOM_ID);
    if (!room) return;

    // prefer partyUids, then participantUids, then hostUid
    const uids = Array.isArray(room.partyUids) && room.partyUids.length ? room.partyUids
              : Array.isArray(room.participantUids) && room.participantUids.length ? room.participantUids
              : (room.hostUid ? [room.hostUid] : []);

    if (!uids.length) return;
    const names = [];
    for (const uid of uids.slice(0,4)){
      // eslint-disable-next-line no-await-in-loop
      const name = (typeof window._et_fetchUsername === 'function') ? (await window._et_fetchUsername(uid)) : uid.slice(0,6);
      names.push(name);
    }
    // If fewer than 4 players, pad with "Slot N"
    while (names.length < 4) names.push(`Slot ${names.length+1}`);

    state.names = names;
    persist(); render();
  }

  // ---------- Init
  (function init(){
    state.mode = resolveMode();
    state.names = resolveNames();
    if (!restore()){ drawWeapons(); persist(); }
    render();
    // Try to replace Slot labels with actual usernames from Firestore
    tryPopulateNamesFromRoom();
  })();
  </script>
</body>
</html>
